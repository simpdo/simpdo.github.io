[{"title":"c++使用模板实现不定长函数参数","path":"/2024/05/13/cpp-params/","content":"使用c++的模板实现不定长函数参数 使用该接口减少逻辑处理中的if，else判断，只需要在最后面判断result的结果 12345678910111213template&lt;typename Func, typename... Args&gt;void SafeRun(const std::string&amp; info, bool&amp; result, Func func, Args&amp;&amp;... args)&#123; if (!result || !func) return; result = func(args...); if (!result) &#123; printf(&quot;%s fail &quot;, info.c_str()); &#125;&#125;","tags":["c++"],"categories":["c++"]},{"title":"linux下ffmpeg c++实现截屏","path":"/2024/05/13/linux-capture/","content":"实现功能使用libX11相关api实现了一下功能 linux下ffmpeg c++实现截屏bmp数据，保存bmp文件 linux desktop登录用户后截屏，系统用户不登陆的情况是无法截屏的，具体的截屏原理研究XWindows系统的实现 截屏实现了2种方法，ffmpeg截屏方便控制参数，X11的截屏比较单调 注意： 多屏截屏会将所有屏幕都截取，然后按照系统设置显示配置的屏幕位置拼接成一张图 实现见代码(相关缺失自行脑补) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &quot;Display.h&quot;#include &lt;map&gt;////////////////////////////////DisplayX11///////////////////////////////////bool DisplayX11::Init()&#123; const char* name = GetDisplayServer(); printf(&quot;DISPLAY: %s &quot;, name); //初始化x11相关 if (!InitNativeHandler(name)) &#123; printf(&quot;init screen fail &quot;); return false; &#125; if (!InitScreens()) &#123; printf(&quot;init screen fail &quot;); return false; &#125; if (!InitFFmpeg(name)) &#123; printf(&quot;init screen capture fail &quot;); return false; &#125; return true;&#125;bool DisplayX11::InitNativeHandler(const char* name)&#123; if (m_native != nullptr) &#123; return true; &#125; m_native = XOpenDisplay(name); if (nullptr == m_native) &#123; printf(&quot;Open X11 display[%s] fail&quot;, name); return false; &#125; Window win = XDefaultRootWindow(m_native); XWindowAttributes attr; int result = XGetWindowAttributes(m_native, win, &amp;attr); if (0 == result) &#123; printf(&quot;Get Window attribute fail&quot;); return false; &#125; m_width = static_cast&lt;int16_t&gt;(attr.width); m_height = static_cast&lt;int16_t&gt;(attr.height); return true;&#125;bool DisplayX11::InitFFmpeg(const char* name)&#123; av_register_all(); avcodec_register_all(); avdevice_register_all(); avformat_network_init(); if (!InitDesktopInput()) &#123; return false; &#125; if (!OpenDesktopStream(name)) &#123; return false; &#125; m_srcFrame = av_frame_alloc(); m_dstFrame = av_frame_alloc(); if(!BindCaptureBuffer()) &#123; return false; &#125; //初始化packet m_packet = av_packet_alloc(); av_new_packet(m_packet, m_codecCtx-&gt;width * m_codecCtx-&gt;height); return true;&#125;bool DisplayX11::InitDesktopInput()&#123; m_inputFormat = av_find_input_format(&quot;x11grab&quot;); // Set up input device (screen) if (nullptr == m_inputFormat) &#123; printf(&quot;Open desktop InputFormat[x11grab] fail&quot;); return false; &#125; return true;&#125;bool DisplayX11::OpenDesktopStream(const char* name)&#123; // Open X11 input char buffer[16] = &#123; &#x27;\\0&#x27; &#125;; snprintf(buffer, sizeof(buffer)-1, &quot;%dx%d&quot;, m_width, m_height); av_dict_set(&amp;m_option, &quot;video_size&quot;, buffer, 0); // memset(buffer, &#x27;\\0&#x27;, sizeof(buffer)); snprintf(buffer, sizeof(buffer)-1, &quot;%d&quot;, m_frameRate) ; av_dict_set(&amp;m_option, &quot;framerate&quot;, buffer, 0); // 显示鼠标设置 memset(buffer, &#x27;\\0&#x27;, sizeof(buffer)); snprintf(buffer, sizeof(buffer)-1, &quot;%d&quot;, m_drawMouse); av_dict_set(&amp;m_option, &quot;draw_mouse&quot;, buffer, 0); // 查找流信息 avformat_open_input(&amp;m_formatCtx, name, m_inputFormat, &amp;m_option); if (avformat_find_stream_info(m_formatCtx, NULL) &lt; 0) &#123; printf(&quot;avformat_find_stream_info cannot find stream info.&quot;); return false; &#125; for (size_t i = 0; i &lt; m_formatCtx-&gt;nb_streams; i++) &#123; if (m_formatCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123; m_videoStreamIndex = static_cast&lt;int&gt;(i); break; &#125; &#125; if (m_videoStreamIndex == -1) &#123; printf(&quot;cannot find video stream.&quot;); return false; &#125; // 查找编码器 AVCodecParameters* pCodecParam = m_formatCtx-&gt;streams[m_videoStreamIndex]-&gt;codecpar; AVCodec* codec = const_cast&lt;AVCodec*&gt;(avcodec_find_decoder(pCodecParam-&gt;codec_id)); if (nullptr == codec) &#123; printf(&quot;avcodec_find_decoder find codec[%d] fail&quot;, pCodecParam-&gt;codec_id); return false; &#125; // 创建编码器上下文 m_codecCtx = avcodec_alloc_context3(codec); if (nullptr == m_codecCtx) &#123; printf(&quot;avcodec_alloc_context3 fail&quot;); return false; &#125; if (avcodec_parameters_to_context(m_codecCtx, pCodecParam) &lt; 0) &#123; printf(&quot;avcodec_parameters_to_context fail&quot;); return false; &#125; // 打开编码器 if (avcodec_open2(m_codecCtx, codec, NULL) &lt; 0) &#123; printf(&quot;avcodec_open2 fail&quot;); return false; &#125; return true;&#125;bool DisplayX11::BindCaptureBuffer()&#123; if (m_bufferSize &gt; 0 &amp;&amp; m_outBuffer != nullptr) &#123; av_free(m_outBuffer); m_bufferSize = 0; &#125; sws_freeContext(m_swsCxt); if (m_codecCtx == nullptr) &#123; printf(&quot;Invalid AVCodecContext&quot;); return false; &#125; if (nullptr == m_dstFrame) &#123; printf(&quot;Invalid AVFrame&quot;); return false; &#125; // 创建数据buffer m_bufferSize = av_image_get_buffer_size(m_pixelFormat, m_codecCtx-&gt;width, m_codecCtx-&gt;height, 1); m_outBuffer = (unsigned char *)av_malloc(m_bufferSize); // 设置帧数据转换上下文 m_swsCxt = sws_getContext(m_codecCtx-&gt;width, m_codecCtx-&gt;height, m_codecCtx-&gt;pix_fmt, m_codecCtx-&gt;width, m_codecCtx-&gt;height, m_pixelFormat, SWS_BILINEAR, NULL, NULL, NULL); // 绑定内存块 if (av_image_fill_arrays(m_dstFrame-&gt;data, m_dstFrame-&gt;linesize, m_outBuffer, m_pixelFormat, m_codecCtx-&gt;width, m_codecCtx-&gt;height, 1) &lt; 0) &#123; printf(&quot;av_image_fill_arrays fail&quot;); return false; &#125; printf(&quot;bind dest AVFrame buffer success! &quot;); return true;&#125;void DisplayX11::DisconnectDesktop()&#123; if(avcodec_is_open(m_codecCtx)) &#123; avcodec_close(m_codecCtx); &#125; if (m_codecCtx) &#123; avcodec_free_context(&amp;m_codecCtx); &#125; if (m_formatCtx) &#123; avformat_close_input(&amp;m_formatCtx); avformat_free_context(m_formatCtx); &#125; if (nullptr != m_option) &#123; av_dict_free(&amp;m_option); &#125; m_videoStreamIndex = -1;&#125;bool DisplayX11::InitShmImage()&#123; //初始化XShmSegmentInfo m_shmSegInfo = new XShmSegmentInfo(); m_shmSegInfo-&gt;shmid = -1; //初始化XImage int width = DisplayWidth(m_native, 0); int height = DisplayHeight(m_native, 0); m_xImage = XShmCreateImage(m_native, DefaultVisual(m_native, 0), 32, ZPixmap, NULL, m_shmSegInfo, width, height); if (nullptr == m_xImage) &#123; printf(&quot;can not create XshmImage&quot;); return false; &#125; size_t len = m_xImage-&gt;bytes_per_line * m_xImage-&gt;height; m_shmSegInfo-&gt;shmid = shmget(IPC_PRIVATE, len, IPC_CREAT | 0777); if (m_shmSegInfo-&gt;shmid == -1) &#123; printf(&quot;shmid failed&quot;); return false; &#125; m_xImage-&gt;data = (char* )shmat(m_shmSegInfo-&gt;shmid, 0, 0); m_shmSegInfo-&gt;shmaddr = m_xImage-&gt;data; if(!XShmAttach(m_native, m_shmSegInfo))&#123; printf(&quot;XShmAttach failed&quot;); return false; &#125; return true;&#125;bool DisplayX11::CaptureX11(uint8_t** data, size_t&amp; len, size_t&amp; linebytes)&#123; if (!XShmGetImage(m_native, RootWindow(m_native, 0), m_xImage, 0, 0, AllPlanes)) &#123; printf(&quot;XShmGetImage fail&quot;); return false; &#125; *data = (uint8_t*)(m_xImage-&gt;data); len = m_xImage-&gt;bytes_per_line * m_xImage-&gt;height; linebytes = m_xImage-&gt;bytes_per_line; return true; srand(time(nullptr)); if (m_outBuffer == nullptr) &#123; size_t length = 2560 * 1440 * 3; m_outBuffer = (uint8_t*)malloc(length); for(size_t i = 0; i &lt; length ; ++i) &#123; m_outBuffer[i] = char(rand() % 128); &#125; *data = m_outBuffer; len = length; linebytes = 2560*3; return true; &#125;&#125;bool DisplayX11::Capture(uint8_t** data, size_t&amp; len, size_t&amp; linebytes)&#123; //使用m_pixelFormat获取截屏数据 &#123; static AVPixelFormat pixelFormat = m_pixelFormat; if (pixelFormat != m_pixelFormat) &#123; if (!BindCaptureBuffer()) &#123; return false; &#125; pixelFormat = m_pixelFormat; &#125; &#125; //是不是可以在不重新打开流的情况下，直接设置显示鼠标，TODO：研究 &#123; static int drawMouse = m_drawMouse; if (drawMouse != m_drawMouse) &#123; DisconnectDesktop(); if (!OpenDesktopStream(GetDisplayServer())) &#123; return false; &#125; drawMouse = m_drawMouse; &#125; &#125; if (av_read_frame(m_formatCtx, m_packet) &lt; 0) &#123; printf(&quot;ffmpeg read frame fail&quot;); return false; &#125; if (m_packet-&gt;stream_index == m_videoStreamIndex) &#123; if (avcodec_send_packet(m_codecCtx, m_packet) &gt;= 0) &#123; int success = avcodec_receive_frame(m_codecCtx, m_srcFrame); if (success != 0) &#123; printf(&quot;ffmpeg read frame result: %d &quot;, success); return false; &#125; // 将解码后数据转换为Rgb格式数据 sws_scale(m_swsCxt, m_srcFrame-&gt;data, m_srcFrame-&gt;linesize, 0, m_codecCtx-&gt;height, m_dstFrame-&gt;data, m_dstFrame-&gt;linesize); *data = m_outBuffer; len = m_bufferSize; linebytes = m_dstFrame-&gt;linesize[0]; &#125; av_packet_unref(m_packet); &#125; return true;&#125;const char* DisplayX11::GetDisplayServer()&#123; const char* name = getenv(&quot;DISPLAY&quot;); return (name == nullptr ? &quot;:0.0&quot; : name); &#125;bool DisplayX11::InitScreens()&#123; if (m_native == nullptr) &#123; return false; &#125; int count = 0; XineramaScreenInfo* infos = XineramaQueryScreens(m_native, &amp;count); for (int i = 0; i &lt; count; ++i) &#123; auto screen = std::make_shared&lt;stScreen&gt;(); screen-&gt;index = infos[i].screen_number; screen-&gt;width = infos[i].width; screen-&gt;height = infos[i].height; screen-&gt;offsetX = infos[i].x_org; screen-&gt;offsetY = infos[i].y_org; printf(&quot;screen[%d] width: %d, height: %d, offset[%d, %d] in display &quot;, i, screen-&gt;width, screen-&gt;height, screen-&gt;offsetX, screen-&gt;offsetY); m_screens.push_back(screen); &#125; return true;&#125;typedef struct /**** BMP file header structure ****/&#123; unsigned int bfSize; /* Size of file */ unsigned short bfReserved1; /* Reserved */ unsigned short bfReserved2; /* ... */ unsigned int bfOffBits; /* Offset to bitmap data */&#125; BITMAPFILEHEADER;typedef struct /**** BMP file info structure ****/&#123; unsigned int biSize; /* Size of info header */ int biWidth; /* Width of image */ int biHeight; /* Height of image */ unsigned short biPlanes; /* Number of color planes */ unsigned short biBitCount; /* Number of bits per pixel */ unsigned int biCompression; /* Type of compression to use */ unsigned int biSizeImage; /* Size of image data */ int biXPelsPerMeter; /* X pixels per meter */ int biYPelsPerMeter; /* Y pixels per meter */ unsigned int biClrUsed; /* Number of colors used */ unsigned int biClrImportant; /* Number of important colors */&#125; BITMAPINFOHEADER;void MySaveBmp(const char *filename, unsigned char *rgbbuf, int width, int height)&#123; BITMAPFILEHEADER bfh; BITMAPINFOHEADER bih; /* * Magic number for file. It does not fit in the header structure due to * alignment requirements, so put it outside * 文件的魔术字，由于对齐的需要，没办法将魔术字作为BITMAPFILEHEADER的成员，所以 * 这里将魔术字放在BITMAPFILEHEADER开头外面的位置。 */ unsigned short bfType = 0x4d42; //&#x27;BM&#x27; bfh.bfReserved1 = 0; bfh.bfReserved2 = 0; bfh.bfSize = 2 /* 2B魔术字 */ + sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + width * height * 3; bfh.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER); bih.biSize = sizeof(BITMAPINFOHEADER); bih.biWidth = width; bih.biHeight = height; bih.biPlanes = 1; bih.biBitCount = 24; bih.biCompression = 0; bih.biSizeImage = 0; bih.biXPelsPerMeter = 5000; bih.biYPelsPerMeter = 5000; bih.biClrUsed = 0; bih.biClrImportant = 0; FILE *file = fopen(filename, &quot;wb&quot;); if (!file) &#123; printf(&quot;Could not write file &quot;); return; &#125; /*Write headers*/ fwrite(&amp;bfType, sizeof(bfType), 1, file); fwrite(&amp;bfh, sizeof(bfh), 1, file); fwrite(&amp;bih, sizeof(bih), 1, file); fwrite(rgbbuf, width * height * 3, 1, file); fclose(file);&#125;","tags":["c++","linux","ffmpeg","libX11"],"categories":["c++"]},{"title":"C++实现Linux下鼠标键盘的模拟","path":"/2024/05/13/linux-input/","content":"C++实现Linux下模拟鼠标键盘，代码摘抄，仅作参数，不保证编译通过 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140//鼠标键定义enum class MouseKey : uint8_t&#123; Left = 0, //鼠标左键 Middle = 1, //鼠标中键 Right = 2, //鼠标右键 WheelUp = 3, //鼠标滚轮上 WheelDown = 4, //鼠标滚轮下 Invalid = 0xff,&#125;;enum class MouseKeyMask : uint8_t&#123; LeftMask = 0x1, MiddleMask = 0x2, RightMask = 0x4, WheelUpMask = 0x8, WheelDownMask = 0x10,&#125;;static const int kMouseKey2X11[] = &#123; Button1, Button2, Button3, Button4, Button5 &#125;;#include &lt;unistd.h&gt;#include &lt;bitset&gt;#include &lt;iostream&gt;#include &lt;X11/extensions/XTest.h&gt;#include &lt;X11/extensions/XKBstr.h&gt;#include &lt;X11/XKBlib.h&gt;#define CHECK_HANDLE(retVal) \\ if (nullptr == display) \\ &#123; \\ printf(&quot;X11 Display invalid&quot;); \\ return retVal; \\ &#125;extern Display* display;bool MoveMouse(int posX, int posY)&#123; CHECK_HANDLE(false); XTestFakeMotionEvent(display, -1, posX, posY, CurrentTime); XFlush(display); return true;&#125;//key需要转换，工程中是windows下传过来的bool KeyDown(uint32_t key)&#123; CHECK_HANDLE(false); KeyCode code = XKeysymToKeycode(display, key); XTestFakeKeyEvent(display, code, 1, CurrentTime); XSync(display, False); return true;&#125;bool KeyUp(uint32_t key)&#123; CHECK_HANDLE(false); KeyCode code = XKeysymToKeycode(display, key); XTestFakeKeyEvent(display, code, 0, CurrentTime); XSync(display, False); return true;&#125;bool MouseButtonEvent(MouseKey key, int pressed)&#123; CHECK_HANDLE(false); if (key &lt; MouseKey::Left || key &gt; MouseKey::WheelDown) &#123; printf(&quot;[InputEvent Mouse]invalid mouse key[%d]&quot;, key); return false; &#125; unsigned button = kMouseKey2X11[static_cast&lt;int&gt;(key)]; XTestFakeButtonEvent(display, button, pressed, CurrentTime); XFlush(display); return true;&#125;extern MouseEvent lastEvent;void ProcessMouseEvent(const MouseEvent&amp; event)&#123; printf(&quot;[Mouse] pos&#123;%d, %d&#125;, mask: %s&quot;, event.posX, event.posY, std::bitset&lt;8&gt;(int(event.mask)).to_string().c_str()); //鼠标的左中右键可以同时按下 uint8_t mouseMask = 0; for (MouseKey key : &#123;MouseKey::Left, MouseKey::Middle, MouseKey::Right&#125;) &#123; uint8_t keyMask = (0x1 &lt;&lt; static_cast&lt;uint8_t&gt;(key)); //事件变化的第一次发送事件给系统 if ((keyMask &amp; event.mask) == keyMask) //down &#123; if ((lastEvent.mask &amp; keyMask) == 0) &#123; PressMouseButton(key); printf(&quot;[InputEvent Mouse] key[%d] pressed down&quot;, key); &#125; lastEvent.mask |= keyMask; &#125; else &#123; if ((lastEvent.mask &amp; keyMask) == keyMask) &#123; ReleaseMouseButton(key); printf(&quot;[InputEvent Mouse] key[%d] pressed down&quot;, key); lastEvent.mask &amp;= (~keyMask); &#125; &#125; &#125; //滚轮上下滚动互斥, 滚轮不需要上次的， 滚轮处理需要同时调用按下和释放，否则不生效 uint8_t wheelUpMask = (0x1 &lt;&lt; static_cast&lt;uint8_t&gt;(MouseKey::WheelUp)); uint8_t wheelDownMask = (0x1 &lt;&lt; static_cast&lt;uint8_t&gt;(MouseKey::WheelDown)); if ((event.mask &amp; wheelUpMask) == wheelUpMask) &#123; PressMouseButton(MouseKey::WheelUp); ReleaseMouseButton(MouseKey::WheelUp); printf(&quot;[InputEvent Mouse] key[WheelUp] pressed down&quot;); &#125; else if ((event.mask &amp; wheelDownMask) == wheelDownMask) &#123; printf(&quot;[InputEvent Mouse] key[WheelDown] pressed down&quot;); PressMouseButton(MouseKey::WheelDown); ReleaseMouseButton(MouseKey::WheelDown); &#125; int16_t posX = event.posX + m_region.posX; int16_t posY = event.posY + m_region.posY; if ( posX != lastEvent.posX || posY != lastEvent.posY) &#123; MoveMouse(posX, posY); lastEvent.posX = posX; lastEvent.posY = posY; &#125;&#125;void ProcessKeyEvent(uint32_t key, uint8_t pressed)&#123; key = (key &amp; 0xFFFF); if (0 == pressed) KeyUp(key); else KeyDown(key);&#125;","tags":["c++","linux","X11"],"categories":["c++"]},{"title":"使用Hexo搭建博客","path":"/2024/05/13/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":["杂货"]}]